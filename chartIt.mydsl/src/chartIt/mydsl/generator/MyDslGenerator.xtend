/*
 * generated by Xtext 2.27.0
 */
package chartIt.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import chartIt.Program
import chartIt.CsvLoader
import chartIt.DataFiltering
import chartIt.GraphDrawing
import java.io.BufferedReader
import java.util.List
import java.io.FileReader
import java.util.stream.Collectors
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var Program prog = resource.contents.get(0) as Program;
		//extraire l'id
		var id_chart = prog.id
		var String res = "<!DOCTYPE html>"+"\n"+"<head>"+"\n"+"</head>"+"\n"+"<body>"+"\n"+"<div>"+"\n"+"  <canvas id=" + "\"" + id_chart + "\"" +"></canvas>"+"\n"+"</div>"+"\n"
		var exist_condition = false
		var path =''
		val csv_parser = newArrayList()
		for(f : prog.functions){
			if (f instanceof CsvLoader){
				//extraire le path
				path = f.path
				csv_parser+=csvload(path) 
				res+= "<script src="+"\""+"https://cdn.jsdelivr.net/npm/chart.js"+"\""+"></script>"+"\n"
				res+= "<!-- <script src="+"\""+"https://raw.githubusercontent.com/chartjs/Chart.js/master/docs/scripts/utils.js"+"\""+"></script> -->"+"\n"
				res+= "<script>"+"\n"
			}
			
			else if(f instanceof DataFiltering){
				val columns_index = newArrayList()
				val columns_name = newArrayList()
				for (col : f.column_filter){
					//extraire les indices des colonnes a conserver et les conserver dans la liste columns_index
					columns_index+= col.index
					//extraire les nouveaux noms a donner pour ces colonnes et les conserver dans la liste columns_name
					columns_name+= col.new_name_column
				}
				//appel de la fonction fikterprint qui doit retourner le tableau apres filtrage en format json
				res+=filterprint(columns_index,columns_name, csv_parser) + "\n"
				//en cas de presence d'une condition de filtrage des lignes 
				if(f.rowfilter_condition != null) {
					exist_condition = true
					val condition =  f.rowfilter_condition
					//extraire la colonne cible
					val column_condition = condition.column_name
					val op = condition.operator
					//extraire l'operateur
					val opr = op.toString()
					//transformer l'operateur du format caractere en symbole
					var operator = ''
					if (opr == "equal"){
						operator = "=="
					}
					else if (opr == "not_equal"){
						operator = "!="
					}
					else if (opr == "greater_than"){
						operator = ">"
					}
					else if (opr == "greater_than_or_equal"){
						operator = ">="
					}
					else if (opr == "smaller_than"){
						operator = "<"
					}
					else if (opr == "smaller_than_or_equal"){
						operator = "<="
					}
					var string_value=''
					var int_value = 0
					//si la valeur avec laquelle la comparaison est faite est un String
					if (condition.string_value != null){
						string_value = condition.string_value
						res+= "const filteredData = data.filter(row => row."+column_condition+ operator + "\""+string_value+"\""+");"+"\n"
					}
					//si la valeur avec laquelle la comparaison est faite est un int
					else {
						int_value = condition.int_value
						res+= "const filteredData = data.filter(row => row."+column_condition+operator+int_value+");"+"\n"
					}
				}
			}
			else if(f instanceof GraphDrawing){
				val id = id_chart
				//extraire le type de graph
				val type = f.graph_type
				//extraire la colonne qui doit etre represente par l'axe des abscisse
				val abs_column = f.abs_column
				//extraire la colonne/s qui doit etre represente par l'axe des ordonnee
				val ord_column = f.ord_column
				//extraire les labels des ord_columns
				val labels = f.label
				//extraire le titre s'il existe
				var title_list = ''
				if (f.title != null){
					val title = f.title
					for(t : title){
						title_list += t
					}
				}
				//savoir si la courbe doit etre rempli ou non
				val fill = f.fill
				val data = #["data", "filteredData"]
				//en cas de presence d'une condition de filtrage des lignes on utilise le data initiale (apres filtrage des colonnes seulement)
				if (exist_condition == true){
					res+= graphprint(id, type, abs_column, ord_column, labels, fill, data.get(1), title_list)+ "\n"
				}
				//en cas d'abscence d'une condition de filtrage des lignes on utilise filteredDataqui correspond au data apres filtrage des lignes
				else{
					res+= graphprint(id, type, abs_column, ord_column, labels, fill,  data.get(0), title_list)+ "\n"
				}	
			}
		}
		res+="</script>" + "\n" + "</body>" 
		fsa.generateFile(prog.name+'.html',res);
	}
	def List<String> csvload(String path){
		
		val csvFile = path
		val bufferedReader = new BufferedReader(new FileReader(csvFile))
		//conserver le contenu du csv dans la liste lines
		val lines = bufferedReader.lines().collect(Collectors.toList())
		
		return lines 
	}
	def String filterprint(List<Integer> columns_index, List<String> columns_name, List<String> csv_parser){
		val nb_columns = columns_index.size()
		val lines  =  csv_parser
		val sb = new StringBuilder()
		sb.append("const data = [" + "\n")
		//parser le contenu du csv
		for (j : 2 ..< lines.size()) {
          val line = lines.get(j)
		  val cells = line.split(";")
		  //conservation en format json
		  sb.append("{")
		  for (i : 0 ..< nb_columns){
		  	sb.append(columns_name.get(i))
		  	sb.append(":")
		  	val cell = cells.get(columns_index.get(i));
		  	if (cell instanceof String) {
       		 sb.append("\"" + cell + "\"");
    	  	}
    	  	else {
    	  		sb.append(cell)
    	  	}
		  	sb.append(",")
		  } 
		  sb.setLength(sb.length() - 1)
		  sb.append("},"+"\n")
		}
		sb.setLength(sb.length() - 1)
		sb.append("\n"+"];")
		val table  = sb.toString()
		
		return table
	}
	def String graphprint(String id, String type, String abs_column, List<String> ord_column, List<String> labels, List<Boolean> fill, String data, String title_list){
		val sb = new StringBuilder()
		sb.append("new Chart(" + "\n")
		sb.append("document.getElementById(" + "\'" + id  + "\'" + ")," + "\n")
		sb.append("{"+ "\n")
		sb.append("type: " + "\'" + type + "\'" + "," + "\n")
		sb.append("data: {" + "\n")
		sb.append("labels: "+data+".map(row => row." + abs_column +")," + "\n")
		sb.append("datasets: [" + "\n")
		val nb_ord_column = labels.size()
		for (i : 0 ..< nb_ord_column){
			sb.append("{" + "\n")
			sb.append("label: " + "\"" + labels.get(i) + "\"" + "," + "\n")
			sb.append("data: "+data+".map(row => row." + ord_column.get(i) + ")," + "\n")
			sb.append("fill:"+fill.get(i)+ "," + "\n")
			sb.append("}," + "\n")
		}
		sb.append("]" + "\n")
		sb.append("}" + "\n")
		sb.append(","+"\n")
		sb.append("options: {"+"\n"+"plugins: {"+"\n"+"title: {"+"\n")
		
		if (title_list==''){
			sb.append("display: "+false+","+"\n")
			sb.append("text: "+"\'"+title_list+"\'"+"\n")
		}
		else{
			sb.append("display: "+true+","+"\n")
			sb.append("text: "+"\'"+title_list+"\'"+"\n")
		}
		sb.append("}"+"\n"+"}"+"\n"+"}"+"\n")
		sb.append("}" + "\n")
		sb.append(");" + "\n")
		val table = sb.toString()
		//retoune un String contenant tot les infos necessaires pour la construction du graph
		return table
	}
}





